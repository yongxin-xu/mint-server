package protocol

import (
	"database/sql"
	"fmt"
	mintcommon "mint-server/common"
	"mint-server/config"

	"github.com/go-sql-driver/mysql"
)

// Currently, we use short connection to DB

// signUpTry use a db connection to try signing up.
// return vals:
// 		1. status of the result
//		2. user id
//		3. id of the account generated by the database, if failed, id is 0
//		4. error
func signUpTry(account string, password string) (ServerReturnCode, int, error) {
	dbconn, err := getDBConn()
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	// 1. [set transaction level]
	if _, err := dbconn.Query("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 2. [begin transaction]
	if _, err := dbconn.Query("BEGIN"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 3. [insert user info] insert into _user_info values ...
	insert_stmt, err := dbconn.Prepare("INSERT INTO muser(_account, _password) VALUES(?, ?)")
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	_, err = insert_stmt.Exec(account, password)
	me, ok := err.(*mysql.MySQLError)
	if ok && me.Number == 1062 {
		return ServerReturnCode_ACC_EXISTED, 0, nil
	}
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 4. select ... => get id
	select_sql := fmt.Sprintf("SELECT _id FROM muser WHERE _account = '%s' and _password = '%s'",
		account, password)
	rets, err := dbconn.Query(select_sql)
	var _id int
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	count := 0
	for rets.Next() {
		err = rets.Scan(&_id)
		if err != nil {
			return ServerReturnCode_DBFAIL, 0, err
		}
		count++
	}
	if count == 0 {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 5. commit()
	if _, err := dbconn.Query("COMMIT"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	return ServerReturnCode_OK, _id, nil
}

// signInTry use a db connection to try signing in
// return vals:
//		1. status of the result
//		2. user id
//		3. current user progress (chapter, section)
//		4. error
func signInTry(account string, password string) (ServerReturnCode, int, error) {
	select_sql := fmt.Sprintf("SELECT _id FROM muser WHERE _account = '%s' and _password = '%s'",
		account, password)

	dbconn, err := getDBConn()
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	// 1. set transaction level
	if _, err := dbconn.Query("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 2. begin transaction
	if _, err := dbconn.Query("BEGIN"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}

	// 3. select ... => get id
	rets, err := dbconn.Query(select_sql)
	var _id int
	if err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	count := 0
	for rets.Next() {
		err = rets.Scan(&_id)
		if err != nil {
			return ServerReturnCode_DBFAIL, 0, err
		}
		count++
	}
	if count == 0 {
		return ServerReturnCode_ACC_PSW_NO_MATCH, 0, err
	}

	// 4. commit()
	if _, err := dbconn.Query("COMMIT"); err != nil {
		return ServerReturnCode_DBFAIL, 0, err
	}
	return ServerReturnCode_OK, _id, nil
}

// Set user progress
func setProgress(_id int, progress *ReqProgress) (*RetProgress, error) {
	rspp := &RetProgress{Chapter: -1, Section: -1}

	dbconn, err := getDBConn()
	if err != nil {
		return rspp, err
	}
	// 1. set transaction level
	if _, err := dbconn.Query("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ"); err != nil {
		return rspp, err
	}

	// 2. begin transaction
	if _, err := dbconn.Query("BEGIN"); err != nil {
		return rspp, err
	}

	// 3. [insert user info] insert into _user_info values ...
	insert_stmt, err := dbconn.Prepare("UPDATE muser SET _chapter = ?, _section = ? WHERE _id = ?")
	if err != nil {
		return rspp, err
	}
	if _, err = insert_stmt.Exec(progress.GetChapter(), progress.GetSection(), _id); err != nil {
		return rspp, err
	}

	// 4. [commit]
	if _, err := dbconn.Query("COMMIT"); err != nil {
		return rspp, err
	}

	rspp.Chapter = progress.GetChapter()
	rspp.Section = progress.GetSection()

	return rspp, nil
}

// Get user progress
func getProgress(_id int) (*RetProgress, error) {
	rp := &RetProgress{Chapter: -1, Section: -1}
	select_sql := fmt.Sprintf("SELECT _id, _chapter, _section FROM muser WHERE _id = '%d'",
		_id)

	dbconn, err := getDBConn()
	if err != nil {
		return rp, err
	}
	// 1. set transaction level
	if _, err := dbconn.Query("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ"); err != nil {
		return rp, err
	}

	// 2. begin transaction
	if _, err := dbconn.Query("BEGIN"); err != nil {
		return rp, err
	}

	// 3. select ... => get id
	rets, err := dbconn.Query(select_sql)
	var _cid int
	var _charpter int
	var _section int
	if err != nil {
		return rp, err
	}
	count := 0
	for rets.Next() {
		err = rets.Scan(&_cid, &_charpter, &_section)
		if err != nil {
			return rp, err
		}
		rp.Chapter = int32(_charpter)
		rp.Section = int32(_section)
		count++
	}
	if count == 0 {
		return rp, err
	}

	// 4. commit()
	if _, err := dbconn.Query("COMMIT"); err != nil {
		return rp, err
	}
	return rp, nil
}

func getDBConn() (*sql.DB, error) {
	uname := config.GlobalConfiguration.DBUser
	password := config.GlobalConfiguration.DBPassword
	ipAddress := config.GlobalConfiguration.DBHost
	port := config.GlobalConfiguration.DBPort
	dbName := config.GlobalConfiguration.DBSchemaName
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?", uname, password, ipAddress, port, dbName)
	DB, err := sql.Open("mysql", dsn)
	if err != nil {
		mintcommon.DebugPrint(config.GlobalConfiguration.EnableLog,
			config.GlobalConfiguration.LogToConsole,
			config.GlobalConfiguration.LogPath,
			fmt.Sprintf("mysql connect failed, detail is [%v]", err.Error()))
		return nil, err
	}
	return DB, nil
}
